{"remainingRequest":"C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\node_modules\\babel-loader\\lib\\index.js!C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\src\\vuex\\store.js","dependencies":[{"path":"C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\src\\vuex\\store.js","mtime":1640076478744},{"path":"C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1638433259471},{"path":"C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\node_modules\\babel-loader\\lib\\index.js","mtime":1638433269605}],"contextDependencies":[],"result":["import \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.for-each\";\n// Vuex\nimport Vuex from 'vuex';\nimport Vue from 'vue';\nimport router from \"../router/index\";\nVue.use(Vuex);\nvar store = new Vuex.Store({\n  state: {\n    switchType: 'el-fade-in',\n    catchedRoutes: [],\n    routerTagVisible: true,\n    routerTagClosable: true\n  },\n  mutations: {\n    setSwitchType: function setSwitchType(state, type) {\n      state.switchType = type;\n    },\n    addRoute: function addRoute(state, toRoute) {\n      if (toRoute.meta != undefined && toRoute.meta.notCatche != undefined && toRoute.meta.notCatche) {// void\n      } else if (toRoute.path === '/') {// void\n      } else {\n        var hasRoute = false;\n        state.catchedRoutes.forEach(function (route) {\n          if (route.path === toRoute.path) {\n            hasRoute = true;\n          }\n        });\n\n        if (!hasRoute) {\n          state.catchedRoutes.push(toRoute);\n        }\n      }\n    },\n    removeRoute: function removeRoute(state, route) {\n      state.catchedRoutes.splice(state.catchedRoutes.indexOf(route), 1);\n\n      if (route.path === router.currentRoute.path) {\n        router.push({\n          path: state.catchedRoutes[0] ? state.catchedRoutes[0].path : '/'\n        });\n      }\n    },\n    clearAllRoutes: function clearAllRoutes(state) {\n      state.catchedRoutes = [];\n    },\n    setRouterTagVisible: function setRouterTagVisible(state, visible) {\n      state.routerTagVisible = visible;\n    },\n    setRouterTagClosable: function setRouterTagClosable(state, closable) {\n      state.routerTagClosable = closable;\n    }\n  }\n});\nexport default store;",{"version":3,"sources":["C:\\Users\\猫丞\\Desktop\\9M\\frontendVue\\src\\vuex\\store.js"],"names":["Vuex","Vue","router","use","store","Store","state","switchType","catchedRoutes","routerTagVisible","routerTagClosable","mutations","setSwitchType","type","addRoute","toRoute","meta","undefined","notCatche","path","hasRoute","forEach","route","push","removeRoute","splice","indexOf","currentRoute","clearAllRoutes","setRouterTagVisible","visible","setRouterTagClosable","closable"],"mappings":";;;AAAA;AACA,OAAOA,IAAP,MAAiB,MAAjB;AACA,OAAOC,GAAP,MAAgB,KAAhB;AACA,OAAOC,MAAP;AAEAD,GAAG,CAACE,GAAJ,CAAQH,IAAR;AAEA,IAAMI,KAAK,GAAG,IAAIJ,IAAI,CAACK,KAAT,CAAe;AAC3BC,EAAAA,KAAK,EAAE;AACLC,IAAAA,UAAU,EAAE,YADP;AAELC,IAAAA,aAAa,EAAE,EAFV;AAGLC,IAAAA,gBAAgB,EAAE,IAHb;AAILC,IAAAA,iBAAiB,EAAE;AAJd,GADoB;AAO3BC,EAAAA,SAAS,EAAE;AACTC,IAAAA,aADS,yBACKN,KADL,EACYO,IADZ,EACkB;AACzBP,MAAAA,KAAK,CAACC,UAAN,GAAmBM,IAAnB;AACD,KAHQ;AAITC,IAAAA,QAJS,oBAIAR,KAJA,EAIOS,OAJP,EAIgB;AACvB,UAAIA,OAAO,CAACC,IAAR,IAAgBC,SAAhB,IAA6BF,OAAO,CAACC,IAAR,CAAaE,SAAb,IAA0BD,SAAvD,IAAoEF,OAAO,CAACC,IAAR,CAAaE,SAArF,EAAgG,CAC9F;AACD,OAFD,MAEO,IAAIH,OAAO,CAACI,IAAR,KAAiB,GAArB,EAA0B,CAC/B;AACD,OAFM,MAEA;AACL,YAAIC,QAAQ,GAAG,KAAf;AACAd,QAAAA,KAAK,CAACE,aAAN,CAAoBa,OAApB,CAA4B,UAAAC,KAAK,EAAI;AACnC,cAAIA,KAAK,CAACH,IAAN,KAAeJ,OAAO,CAACI,IAA3B,EAAiC;AAC/BC,YAAAA,QAAQ,GAAG,IAAX;AACD;AACF,SAJD;;AAKA,YAAI,CAACA,QAAL,EAAe;AACbd,UAAAA,KAAK,CAACE,aAAN,CAAoBe,IAApB,CAAyBR,OAAzB;AACD;AACF;AACF,KApBQ;AAqBTS,IAAAA,WArBS,uBAqBGlB,KArBH,EAqBUgB,KArBV,EAqBiB;AACxBhB,MAAAA,KAAK,CAACE,aAAN,CAAoBiB,MAApB,CAA2BnB,KAAK,CAACE,aAAN,CAAoBkB,OAApB,CAA4BJ,KAA5B,CAA3B,EAA+D,CAA/D;;AACA,UAAIA,KAAK,CAACH,IAAN,KAAejB,MAAM,CAACyB,YAAP,CAAoBR,IAAvC,EAA6C;AAC3CjB,QAAAA,MAAM,CAACqB,IAAP,CAAY;AACVJ,UAAAA,IAAI,EAAEb,KAAK,CAACE,aAAN,CAAoB,CAApB,IAAyBF,KAAK,CAACE,aAAN,CAAoB,CAApB,EAAuBW,IAAhD,GAAuD;AADnD,SAAZ;AAGD;AACF,KA5BQ;AA6BTS,IAAAA,cA7BS,0BA6BMtB,KA7BN,EA6Ba;AACpBA,MAAAA,KAAK,CAACE,aAAN,GAAsB,EAAtB;AACD,KA/BQ;AAgCTqB,IAAAA,mBAhCS,+BAgCWvB,KAhCX,EAgCkBwB,OAhClB,EAgC2B;AAClCxB,MAAAA,KAAK,CAACG,gBAAN,GAAyBqB,OAAzB;AACD,KAlCQ;AAmCTC,IAAAA,oBAnCS,gCAmCYzB,KAnCZ,EAmCmB0B,QAnCnB,EAmC6B;AACpC1B,MAAAA,KAAK,CAACI,iBAAN,GAA0BsB,QAA1B;AACD;AArCQ;AAPgB,CAAf,CAAd;AAgDA,eAAe5B,KAAf","sourcesContent":["// Vuex\r\nimport Vuex from 'vuex'\r\nimport Vue from 'vue'\r\nimport router from '../router/index'\r\n\r\nVue.use(Vuex)\r\n\r\nconst store = new Vuex.Store({\r\n  state: {\r\n    switchType: 'el-fade-in',\r\n    catchedRoutes: [],\r\n    routerTagVisible: true,\r\n    routerTagClosable: true,\r\n  },\r\n  mutations: {\r\n    setSwitchType(state, type) {\r\n      state.switchType = type\r\n    },\r\n    addRoute(state, toRoute) {\r\n      if (toRoute.meta != undefined && toRoute.meta.notCatche != undefined && toRoute.meta.notCatche) {\r\n        // void\r\n      } else if( toRoute.path === '/' ){\r\n        // void\r\n      } else {\r\n        let hasRoute = false;\r\n        state.catchedRoutes.forEach(route => {\r\n          if (route.path === toRoute.path) {\r\n            hasRoute = true;\r\n          }\r\n        })\r\n        if (!hasRoute) {\r\n          state.catchedRoutes.push(toRoute)\r\n        }\r\n      }\r\n    },\r\n    removeRoute(state, route) {\r\n      state.catchedRoutes.splice(state.catchedRoutes.indexOf(route), 1)\r\n      if( route.path === router.currentRoute.path ){\r\n        router.push({\r\n          path: state.catchedRoutes[0] ? state.catchedRoutes[0].path : '/'\r\n        }) \r\n      }\r\n    },\r\n    clearAllRoutes(state) {\r\n      state.catchedRoutes = []\r\n    },\r\n    setRouterTagVisible(state, visible) {\r\n      state.routerTagVisible = visible\r\n    },\r\n    setRouterTagClosable(state, closable) {\r\n      state.routerTagClosable = closable\r\n    }\r\n  }\r\n});\r\n\r\nexport default store"]}]}